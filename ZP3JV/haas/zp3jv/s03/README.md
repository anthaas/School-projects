# Úkoly

<ol>

<li>
<p>Implementujte statickou metodu <code>int[] odd(int[] foo)</code> vracející pole čísel, kde budou pouze lichá čísla z argumentu <code>foo</code>.</p></li>

<li>
<p>Implementujte statickou metodu <code>List&lt;Object&gt; odd(List&lt;Object&gt; foo)</code> vracející seznam čísel, kde budou pouze lichá čísla <code>foo</code>. Pokud argument <code class="prettyprint">foo</code> obsahuje objekt, který není celé číslo, je tento objekt ignorován. Tuto funkcionalitu ověřte.</p></li>


<li>
<p>Implementujte statickou metodu <code>List&lt;Integer&gt; oddNumbers(List&lt;Integer&gt; foo)</code> vracející seznam čísel, kde budou pouze lichá čísla z <code>foo</code>.</p></li>

<li>
<p>S využítím třídy <code>Point</code> z minulého cvičení implementujte statickou metodu <code>Point nearest(Point p, List&lt;Point&gt; points)</code>, která vrací ze seznamu <code>points</code> bod, který je nejblíže bodu <code>p</code>.</li>

<li>
<p>Implementujte funkce <code>int[] merge(int[], int[])</code> a <code>List&lt;Integer&gt; merge(List&lt;Integer&gt;, List&lt;Integer&gt;)</code>, které mají na vstupu setříděné posloupnosti celých čísel a provedou jejich ,,slití'', které vrátí na výstup jako nové setříděné pole/seznam.</li>

<li>
<p>S využitím metody <code>List&lt;Integer&gt; merge(List&lt;Integer&gt;, List&lt;Integer&gt;)</code> implementuje metodu <code>List&lt;Integer&gt; mergeSort(List&lt;Integer&gt;)</code>, implementující algoritmus MergeSort. </p></li>

<li>
<p>(Nepovinný). Ověřte si rychlost metody <code>mergeSort</code>, když budete v metodě <code>merge</code> vytvářet seznam jako <code>ArrayList</code> a když budete používat <code>LinkedList</code>. Využijte metody <code>System.currentTimeMillis()</code>.</p></li>

</ol>
